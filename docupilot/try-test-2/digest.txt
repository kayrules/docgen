Directory structure:
‚îî‚îÄ‚îÄ try-test-2/
    ‚îî‚îÄ‚îÄ streamlit_app.py

================================================
FILE: streamlit_app.py
================================================
import streamlit as st
import os
import tempfile
import zipfile
import shutil
import json
from pathlib import Path
import subprocess
import sys
from datetime import datetime
import base64

# Import the existing flow functionality
from flow import create_tutorial_flow
from utils.call_llm import call_llm

# Page configuration
st.set_page_config(
    page_title="CodeX - AI Documentation Generator",
    page_icon="üìö",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        padding: 2rem;
        border-radius: 10px;
        margin-bottom: 2rem;
        color: white;
        text-align: center;
    }
    .stButton > button {
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 5px;
        padding: 0.5rem 1rem;
        font-weight: bold;
    }
    .stButton > button:hover {
        background: linear-gradient(90deg, #5a6fd8 0%, #6a4190 100%);
    }
    .download-section {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 10px;
        margin: 1rem 0;
    }
    .file-card {
        background-color: white;
        padding: 1rem;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
        margin: 0.5rem 0;
    }
</style>
""", unsafe_allow_html=True)

# Initialize session state
if 'generated_files' not in st.session_state:
    st.session_state.generated_files = []
if 'project_name' not in st.session_state:
    st.session_state.project_name = ""
if 'output_dir' not in st.session_state:
    st.session_state.output_dir = ""

def extract_zip_file(uploaded_file):
    """Extract uploaded zip file to a temporary directory"""
    temp_dir = tempfile.mkdtemp()  # manually manage temp dir
    temp_path = Path(temp_dir)
    
    zip_path = temp_path / "uploaded.zip"
    with open(zip_path, "wb") as f:
        f.write(uploaded_file.getbuffer())

    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        zip_ref.extractall(temp_path)

    extracted_dirs = [d for d in temp_path.iterdir() if d.is_dir()]
    if extracted_dirs:
        return str(extracted_dirs[0])
    return str(temp_path)

def clone_github_repo(repo_url, github_token=None):
    """Clone GitHub repository to a temporary directory"""
    temp_dir = tempfile.mkdtemp()  # manually create temp dir
    temp_path = Path(temp_dir)

    try:
        # Update repo URL with token if needed
        if github_token:
            repo_url = repo_url.replace("https://", f"https://{github_token}@")

        clone_cmd = ["git", "clone", repo_url, str(temp_path)]
        subprocess.run(clone_cmd, capture_output=True, text=True, check=True)
        return str(temp_path)

    except subprocess.CalledProcessError as e:
        st.error(f"Failed to clone repository: {e.stderr}")
        return None

def generate_documentation_files(project_path, api_key, project_name, language="english"):
    """Generate documentation files using the existing flow"""
    try:
        # Set OpenAI API key
        os.environ["OPENAI_API_KEY"] = api_key
        
        # Initialize shared dictionary
        shared = {
            "repo_url": None,
            "local_dir": project_path,
            "project_name": project_name,
            "github_token": None,
            "output_dir": "output",
            "include_patterns": {
                "*.py", "*.js", "*.jsx", "*.ts", "*.tsx", "*.go", "*.java", "*.pyi", "*.pyx",
                "*.c", "*.cc", "*.cpp", "*.h", "*.md", "*.rst", "*Dockerfile",
                "*Makefile", "*.yaml", "*.yml",
            },
            "exclude_patterns": {
                "assets/*", "data/*", "images/*", "public/*", "static/*", "temp/*",
                "*docs/*", "*venv/*", "*.venv/*", "*test*", "*tests/*", "*examples/*",
                "v1/*", "*dist/*", "*build/*", "*experimental/*", "*deprecated/*",
                "*misc/*", "*legacy/*", ".git/*", ".github/*", ".next/*", ".vscode/*",
                "*obj/*", "*bin/*", "*node_modules/*", "*.log"
            },
            "max_file_size": 100000,
            "language": language,
            "use_cache": True,
            "max_abstraction_num": 10,
            "files": [],
            "abstractions": [],
            "relationships": {},
            "chapter_order": [],
            "chapters": [],
            "final_output_dir": None
        }
        
        # Create and run the flow
        tutorial_flow = create_tutorial_flow()
        tutorial_flow.run(shared)
        
        return shared.get("final_output_dir", "output")
    
    except Exception as e:
        st.error(f"Error generating documentation: {str(e)}")
        return None

def create_download_zip(output_dir):
    """Create a zip file containing all generated documentation"""
    import zipfile
    
    zip_path = f"{output_dir}/documentation.zip"
    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, dirs, files in os.walk(output_dir):
            for file in files:
                if file.endswith('.md') or file.endswith('.zip'):
                    continue  # Skip existing zip files
                file_path = os.path.join(root, file)
                arcname = os.path.relpath(file_path, output_dir)
                zipf.write(file_path, arcname)
    
    return zip_path

def main():
    # Header
    st.markdown("""
    <div class="main-header">
        <h1>üìö CodeX</h1>
        <p>AI-Powered Documentation Generator</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Sidebar
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        
        # Project title
        project_title = st.text_input(
            "Project Title",
            value=st.session_state.project_name,
            placeholder="Enter project title (optional)"
        )
        st.session_state.project_name = project_title
        
        # Project description
        project_description = st.text_area(
            "Project Description",
            placeholder="Brief description of your project (optional)"
        )
        
        # Target audience
        target_audience = st.selectbox(
            "Target Audience",
            ["Developers", "End Users", "Contributors", "System Administrators", "General"]
        )
        
        # License type
        license_type = st.selectbox(
            "License Type",
            ["MIT", "Apache 2.0", "GPL v3", "BSD", "Custom", "None"]
        )
        
        # Language
        language = st.selectbox(
            "Documentation Language",
            ["english", "spanish", "french", "german", "chinese", "japanese"]
        )
        
        st.markdown("---")
        st.markdown("### üìä About CodeX")
        st.markdown("""
        CodeX automatically generates professional documentation for your codebase using AI.
        
        **Features:**
        - üìñ README generation
        - üîß Installation guides
        - üìö API documentation
        - üöÄ Getting started guides
        - üìù Code examples
        """)
    
    # Main content
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.header("üîó Input Source")
        
        # Source selection
        source_type = st.radio(
            "Choose your input source:",
            ["GitHub Repository", "Local Codebase (ZIP)"],
            horizontal=True
        )
        
        if source_type == "GitHub Repository":
            repo_url = st.text_input(
                "GitHub Repository URL",
                placeholder="https://github.com/username/repository"
            )
            
            github_token = st.text_input(
                "GitHub Token (Optional)",
                type="password",
                placeholder="For private repositories",
                help="We do not store your token. It's only used during this session."
            )
            
            uploaded_file = None
        else:
            uploaded_file = st.file_uploader(
                "Upload Codebase (ZIP file)",
                type="zip",
                help="Upload a ZIP file containing your codebase"
            )
            repo_url = None
            github_token = None
    
    with col2:
        st.header("üîë OpenAI API Key")
        
        api_key = st.text_input(
            "OpenAI API Key",
            type="password",
            placeholder="sk-...",
            help="We do not store your API key. It's only used during this session."
        )
        
        if api_key:
            st.success("‚úÖ API Key provided")
        else:
            st.warning("‚ö†Ô∏è Please provide your OpenAI API key")
    
    # Generate button
    st.markdown("---")
    
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        generate_button = st.button(
            "üöÄ Generate Documentation",
            use_container_width=True,
            type="primary"
        )
    
    # Processing logic
    if generate_button:
        if not api_key:
            st.error("‚ùå Please provide your OpenAI API key")
            return
        
        if source_type == "GitHub Repository" and not repo_url:
            st.error("‚ùå Please provide a GitHub repository URL")
            return
        
        if source_type == "Local Codebase" and not uploaded_file:
            st.error("‚ùå Please upload a ZIP file")
            return
        
        # Show progress
        with st.spinner("üîÑ Processing your codebase..."):
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            # Step 1: Prepare codebase
            status_text.text("üì• Preparing codebase...")
            progress_bar.progress(20)
            
            project_path = None
            if source_type == "GitHub Repository":
                project_path = clone_github_repo(repo_url, github_token)
                if not project_path:
                    st.error("‚ùå Failed to clone repository")
                    return
            else:
                project_path = extract_zip_file(uploaded_file)
            
            # Step 2: Generate documentation
            status_text.text("ü§ñ Generating documentation with AI...")
            progress_bar.progress(50)
            
            output_dir = generate_documentation_files(
                project_path, 
                api_key, 
                project_title or "Project",
                language
            )
            
            if not output_dir:
                st.error("‚ùå Failed to generate documentation")
                return
            
            # Step 3: Process results
            status_text.text("üìÅ Organizing files...")
            progress_bar.progress(80)
            
            st.session_state.output_dir = output_dir
            st.session_state.generated_files = []
            
            # Collect generated files
            if os.path.exists(output_dir):
                for root, dirs, files in os.walk(output_dir):
                    for file in files:
                        if file.endswith('.md'):
                            file_path = os.path.join(root, file)
                            st.session_state.generated_files.append(file_path)
            
            progress_bar.progress(100)
            status_text.text("‚úÖ Documentation generated successfully!")
            st.success(f"üéâ Generated {len(st.session_state.generated_files)} documentation files!")
    
    # Display results
    if st.session_state.generated_files:
        st.markdown("---")
        st.header("üìÑ Generated Documentation")
        
        # Create tabs for different file types
        tab_names = ["All Files", "README", "Installation", "API Docs", "Examples"]
        tabs = st.tabs(tab_names)
        
        with tabs[0]:  # All Files
            st.subheader("üìÅ All Generated Files")
            
            for i, file_path in enumerate(st.session_state.generated_files):
                with st.expander(f"üìÑ {os.path.basename(file_path)}"):
                    # Read and display file content
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                        
                        st.markdown(content)
                        
                        # Download button for individual file
                        with open(file_path, 'r', encoding='utf-8') as f:
                            st.download_button(
                                label=f"üì• Download {os.path.basename(file_path)}",
                                data=f.read(),
                                file_name=os.path.basename(file_path),
                                mime="text/markdown"
                            )
                    except Exception as e:
                        st.error(f"Error reading file: {e}")
        
        # Create ZIP download
        if st.session_state.output_dir and os.path.exists(st.session_state.output_dir):
            zip_path = create_download_zip(st.session_state.output_dir)
            
            with open(zip_path, 'rb') as f:
                st.download_button(
                    label="üì¶ Download All Documentation (ZIP)",
                    data=f.read(),
                    file_name="codex_documentation.zip",
                    mime="application/zip"
                )
        
        # File statistics
        st.markdown("---")
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Files Generated", len(st.session_state.generated_files))
        
        with col2:
            total_size = sum(os.path.getsize(f) for f in st.session_state.generated_files)
            st.metric("Total Size", f"{total_size / 1024:.1f} KB")
        
        with col3:
            st.metric("Output Directory", st.session_state.output_dir)

if __name__ == "__main__":
    main() 

