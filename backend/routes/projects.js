const express = require('express');
const { execSync, spawn } = require('child_process');
const path = require('path');
const fs = require('fs');
const Project = require('../models/Project');
const router = express.Router();

// Helper function to generate camelCase sidebar ID from project slug
function generateSidebarId(projectSlug) {
  return projectSlug
    .split('-')
    .map((word, index) => index === 0 ? word : word.charAt(0).toUpperCase() + word.slice(1))
    .join('') + 'Sidebar';
}

// Helper function to generate project slug from title
function generateSlug(title) {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-/, '')
    .replace(/-$/, '');
}

// Helper function to update Docusaurus config
async function updateDocusaurusConfig(projectTitle, description) {
  const projectSlug = generateSlug(projectTitle);
  const sidebarId = generateSidebarId(projectSlug);
  const configPath = path.join(__dirname, '../../docupilot/configs.js');

  // Check if config file exists
  if (!fs.existsSync(configPath)) {
    throw new Error(`Config file not found at: ${configPath}`);
  }

  // Read and parse the current config file
  const configContent = fs.readFileSync(configPath, 'utf8');

  // Extract plugins and navbarItems arrays using regex
  const pluginsMatch = configContent.match(/const plugins = (\[[\s\S]*?\]);/);
  const navbarItemsMatch = configContent.match(/const navbarItems = (\[[\s\S]*?\]);/);

  if (!pluginsMatch || !navbarItemsMatch) {
    throw new Error('Could not parse plugins or navbarItems from config file');
  }

  // Parse the arrays (safely evaluate the JavaScript arrays)
  const currentPlugins = eval(pluginsMatch[1]);
  const currentNavbarItems = eval(navbarItemsMatch[1]);

  // Check if plugin already exists
  const pluginExists = currentPlugins.some(plugin =>
    plugin[1] && plugin[1].id === projectSlug
  );

  if (pluginExists) {
    console.log(`Plugin for ${projectSlug} already exists in config`);
    return;
  }

  // Add new plugin to plugins array
  const newPlugin = [
    '@docusaurus/plugin-content-docs',
    {
      id: projectSlug,
      path: projectSlug,
      routeBasePath: projectSlug,
      sidebarPath: `./${projectSlug}/sidebars.js`,
    },
  ];
  currentPlugins.push(newPlugin);

  // Add new navbar item to navbarItems array
  const newNavbarItem = {
    type: 'docSidebar',
    sidebarId: sidebarId,
    label: projectTitle,
    docsPluginId: projectSlug,
  };
  currentNavbarItems.push(newNavbarItem);

  // Generate new configs.js content
  const newConfigContent = `const plugins = ${JSON.stringify(currentPlugins, null, 4).replace(/"/g, "'")};

const navbarItems = ${JSON.stringify(currentNavbarItems, null, 4).replace(/"/g, "'")};

export {
    plugins,
    navbarItems,
}`;

  // Write updated config
  fs.writeFileSync(configPath, newConfigContent, 'utf8');

  // Create sidebar file for the project
  const sidebarPath = path.join(__dirname, `../../docupilot/${projectSlug}/sidebars.js`);
  const sidebarDir = path.dirname(sidebarPath);

  // Ensure directory exists
  if (!fs.existsSync(sidebarDir)) {
    fs.mkdirSync(sidebarDir, { recursive: true });
  }

  const sidebarContent = `// @ts-check
/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */
const sidebars = {
  ${sidebarId}: [
    {
      type: 'html',
      value: '<div style="margin-bottom: 1rem; border-bottom: 1rem solid #ccc; padding-bottom: 1rem;"><div style="font-weight: bold; color: black; text-align: left; margin-bottom: 0.5rem;">${projectTitle}</div><div style="font-size: 14px; color: #666; text-align: left; line-height: 1.4;">${description || `Brief description of ${projectTitle}`}</div></div>',
      defaultStyle: true,
    },
    {
      type: 'autogenerated',
      dirName: '.',
    },
  ],
};

export default sidebars;
`;

  fs.writeFileSync(sidebarPath, sidebarContent, 'utf8');
}

// Helper function to restart only Docusaurus frontend service
async function restartDocusaurus() {
  try {
    const docupilotPath = path.join(__dirname, '../../docupilot');
    
    // Kill only Docusaurus processes on port 3000 (not backend)
    try {
      execSync('lsof -ti:3000 | xargs kill -9', { encoding: 'utf-8', timeout: 5000 });
      console.log('Stopped existing Docusaurus frontend process');
    } catch (killError) {
      // No process to kill, or kill failed - continue anyway
    }
    
    // Wait for port to be free
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Start the rebuild and restart process in background - don't wait for completion
    console.log('Starting Docusaurus rebuild and restart in background...');
    
    // Use spawn instead of execSync to avoid blocking and killing the process
    const restartProcess = spawn('bash', ['-c', 'npm run build && npm run serve'], {
      cwd: docupilotPath,
      detached: true,
      stdio: 'ignore'
    });
    
    // Don't wait for the process - let it run independently
    restartProcess.unref();
    
    console.log('Docusaurus rebuild initiated (running in background)');
  } catch (error) {
    console.warn('Failed to restart Docusaurus frontend:', error.message);
    // Don't throw error - this is not critical for project creation
  }
}

// Helper function to remove project from Docusaurus config
async function removeFromDocusaurusConfig(projectSlug) {
  const configPath = path.join(__dirname, '../../docupilot/configs.js');

  if (!fs.existsSync(configPath)) {
    throw new Error(`Config file not found at: ${configPath}`);
  }

  const sidebarId = generateSidebarId(projectSlug);

  // Read and parse the current config file
  const configContent = fs.readFileSync(configPath, 'utf8');

  // Extract plugins and navbarItems arrays using regex
  const pluginsMatch = configContent.match(/const plugins = (\[[\s\S]*?\]);/);
  const navbarItemsMatch = configContent.match(/const navbarItems = (\[[\s\S]*?\]);/);

  if (!pluginsMatch || !navbarItemsMatch) {
    throw new Error('Could not parse plugins or navbarItems from config file');
  }

  // Parse the arrays (safely evaluate the JavaScript arrays)
  const currentPlugins = eval(pluginsMatch[1]);
  const currentNavbarItems = eval(navbarItemsMatch[1]);

  // Remove plugin from plugins array
  const filteredPlugins = currentPlugins.filter(plugin =>
    !(plugin[1] && plugin[1].id === projectSlug)
  );

  // Remove navbar item from navbarItems array
  const filteredNavbarItems = currentNavbarItems.filter(item =>
    item.sidebarId !== sidebarId
  );

  // Generate new configs.js content
  const newConfigContent = `const plugins = ${JSON.stringify(filteredPlugins, null, 4).replace(/"/g, "'")};

const navbarItems = ${JSON.stringify(filteredNavbarItems, null, 4).replace(/"/g, "'")};

export {
    plugins,
    navbarItems,
}`;

  fs.writeFileSync(configPath, newConfigContent, 'utf8');
  console.log(`Removed ${projectSlug} from Docusaurus config`);

  // Remove sidebar file
  const sidebarPath = path.join(__dirname, `../../docupilot/${projectSlug}/sidebars.js`);
  if (fs.existsSync(sidebarPath)) {
    fs.unlinkSync(sidebarPath);
  }

  // Remove project directory if empty
  const projectDir = path.join(__dirname, `../../docupilot/${projectSlug}`);
  if (fs.existsSync(projectDir)) {
    try {
      fs.rmdirSync(projectDir);
    } catch (e) {
      // Directory not empty, leave it
    }
  }
}

// Create new project
router.post('/create-project', async (req, res) => {
  try {
    const { projectTitle, repositoryUrl, branchName, description } = req.body;

    // Validate required fields
    if (!projectTitle || !repositoryUrl) {
      return res.status(400).json({
        success: false,
        message: 'Project title and repository URL are required'
      });
    }

    // Validate repository URL format (HTTP/HTTPS/SSH)
    const httpPattern = /^https?:\/\/.+/;
    const sshPattern = /^(git@[^:]+:.+|ssh:\/\/git@.+)/; // Support both git@host:user/repo and ssh://git@host/path/repo formats

    if (!httpPattern.test(repositoryUrl) && !sshPattern.test(repositoryUrl)) {
      return res.status(400).json({
        success: false,
        message: 'Please provide a valid repository URL (http://, https://, git@host:user/repo.git, or ssh://git@host/path/repo.git)'
      });
    }

    // Get git username for creator field
    let creator;
    try {
      creator = execSync('git config --global user.name', { encoding: 'utf-8' }).trim();
    } catch {
      try {
        creator = execSync('whoami', { encoding: 'utf-8' }).trim();
      } catch {
        creator = 'Unknown';
      }
    }

    const projectSlug = generateSlug(projectTitle);

    // Create project record in database first
    const project = await Project.create({
      title: projectTitle,
      repository_url: repositoryUrl,
      branch_name: branchName || 'main',
      description: description || `Brief description of ${projectTitle}`,
      creator: creator
    });

    // Define paths
    const repositoriesPath = path.join(__dirname, '../../repositories');
    const docupilotPath = path.join(__dirname, '../../docupilot');
    const templatesPath = path.join(__dirname, '../../templates');
    const repoPath = path.join(repositoriesPath, projectSlug);
    const docPath = path.join(docupilotPath, projectSlug);

    console.log(`[${new Date().toISOString()}] Creating project: ${projectTitle}`);
    console.log(`[${new Date().toISOString()}] Repository path: ${repoPath}`);
    console.log(`[${new Date().toISOString()}] Documentation path: ${docPath}`);

    // Create directories if they don't exist
    if (!fs.existsSync(repositoriesPath)) {
      fs.mkdirSync(repositoriesPath, { recursive: true });
    }
    if (!fs.existsSync(docupilotPath)) {
      fs.mkdirSync(docupilotPath, { recursive: true });
    }

    // Check if project already exists
    if (fs.existsSync(repoPath) || fs.existsSync(docPath)) {
      await project.delete(true); // Clean up database record
      throw new Error('Project workspace already exists');
    }

    let output = '';
    try {
      // Clone repository
      output += `Creating project workspace: ${projectTitle}\n`;
      output += `Project slug: ${projectSlug}\n`;
      output += `Cloning repository...\n`;

      const cloneCommand = `git clone "${repositoryUrl}" "${repoPath}"`;
      if (branchName && branchName !== 'main' && branchName !== 'master') {
        const branchCommand = `git clone -b "${branchName}" "${repositoryUrl}" "${repoPath}"`;
        execSync(branchCommand, {
          encoding: 'utf-8',
          timeout: 120000,
          maxBuffer: 1024 * 1024
        });
      } else {
        execSync(cloneCommand, {
          encoding: 'utf-8',
          timeout: 120000,
          maxBuffer: 1024 * 1024
        });
      }

      output += `Repository cloned successfully\n`;

      // Create documentation directory first
      fs.mkdirSync(docPath, { recursive: true });
      output += `Created documentation directory\n`;

      // Run gitingest on the cloned repository
      output += `Running gitingest analysis...\n`;
      try {
        // Base exclusion patterns for iOS/Android native files, common build folders
        const baseExclusions = [
          '*.xcodeproj',
          '*.xcworkspace',
          '*.pbxproj',
          '*.storyboard',
          '*.xib',
          'android/*',
          'ios/*',
          'node_modules/*',
          'dist/*',
          'build/*',
          '.git/*',
          '*.framework',
          '*.app',
          '*.ipa',
          '*.apk',
          'DerivedData/*',
          'Pods/*'
        ];

        // Read .gitignore if it exists and add those exclusions
        const gitignorePath = path.join(repoPath, '.gitignore');
        let gitignorePatterns = [];
        if (fs.existsSync(gitignorePath)) {
          const gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');
          gitignorePatterns = gitignoreContent
            .split('\n')
            .map(line => line.trim())
            .filter(line => line && !line.startsWith('#') && !line.startsWith('!'));
        }

        // Combine all exclusion patterns
        const allExclusions = [...baseExclusions, ...gitignorePatterns];
        const exclusionFlags = allExclusions.map(pattern => `-e "${pattern}"`).join(' ');

        const fullCommand = `gitingest . ${exclusionFlags}`;

        execSync(fullCommand, {
          encoding: 'utf-8',
          cwd: repoPath,
          timeout: 60000, // 1 minute timeout
          maxBuffer: 10 * 1024 * 1024 // 10MB buffer
        });

        output += `Gitingest analysis completed\n`;

        // Move digest.txt to docupilot directory and clean up repository
        const digestPath = path.join(repoPath, 'digest.txt');
        if (fs.existsSync(digestPath)) {
          const docDigestPath = path.join(docPath, 'digest.txt');
          fs.copyFileSync(digestPath, docDigestPath);
          output += `Repository digest moved to documentation: digest.txt\n`;

          // Clean up the cloned repository - we only needed it for gitingest
          fs.rmSync(repoPath, { recursive: true, force: true });
          output += `Cleaned up temporary repository files\n`;
        } else {
          output += `Warning: Gitingest digest file not found\n`;
          // Still clean up repository even if digest wasn't found
          fs.rmSync(repoPath, { recursive: true, force: true });
          output += `Cleaned up temporary repository files\n`;
        }

      } catch (gitingestError) {
        console.warn(`[${new Date().toISOString()}] Warning: Gitingest failed:`, gitingestError.message);
        output += `Warning: Repository analysis failed - ${gitingestError.message}\n`;

        // Clean up repository even if gitingest failed
        if (fs.existsSync(repoPath)) {
          fs.rmSync(repoPath, { recursive: true, force: true });
          output += `Cleaned up temporary repository files\n`;
        }
        // Don't fail the entire operation if gitingest fails
      }

      // Copy templates (directory already created above)

      // Copy template files
      if (fs.existsSync(templatesPath)) {
        // Copy all files from templates directory
        const copyFiles = (src, dest) => {
          const entries = fs.readdirSync(src, { withFileTypes: true });
          for (const entry of entries) {
            const srcPath = path.join(src, entry.name);
            const destPath = path.join(dest, entry.name);
            if (entry.isDirectory()) {
              fs.mkdirSync(destPath, { recursive: true });
              copyFiles(srcPath, destPath);
            } else {
              let content = fs.readFileSync(srcPath, 'utf8');
              // Replace placeholders in template files
              content = content.replace(/__PROJECT_TITLE__/g, projectTitle);
              content = content.replace(/__PROJECT_DESCRIPTION__/g, description || `Brief description of ${projectTitle}`);
              content = content.replace(/__SIDEBAR_ID__/g, generateSidebarId(projectSlug));
              fs.writeFileSync(destPath, content, 'utf8');
            }
          }
        };

        copyFiles(templatesPath, docPath);
        output += `Template files copied and configured\n`;
      }

      console.log(`[${new Date().toISOString()}] Project created successfully: ${projectTitle}`);

      // Update project status in database
      await project.syncFilesystemStatus();

      // Update Docusaurus config after successful project creation
      try {
        await updateDocusaurusConfig(projectTitle, description || `Brief description of ${projectTitle}`);
        console.log(`[${new Date().toISOString()}] Updated Docusaurus config for: ${projectTitle}`);
      } catch (configError) {
        console.error(`[${new Date().toISOString()}] Warning: Failed to update Docusaurus config:`, configError.message);
        // Don't fail the entire operation if config update fails
      }

      return res.status(200).json({
        success: true,
        message: 'Project created successfully',
        data: project.toJSON(),
        output: output ? output.toString().trim() : ''
      });

    } catch (cloneError) {
      // If git clone fails, clean up any created directories and database record
      // Note: Repository might already be cleaned up by gitingest process
      if (fs.existsSync(repoPath)) {
        fs.rmSync(repoPath, { recursive: true, force: true });
      }
      if (fs.existsSync(docPath)) {
        fs.rmSync(docPath, { recursive: true, force: true });
      }
      await project.delete(true); // Hard delete
      throw cloneError; // Re-throw to be caught by outer catch block
    }

  } catch (error) {
    console.error(`[${new Date().toISOString()}] Error creating project:`, error);
    console.error(`[${new Date().toISOString()}] Error stdout:`, error.stdout?.toString());
    console.error(`[${new Date().toISOString()}] Error stderr:`, error.stderr?.toString());

    // Parse error message for better user feedback
    let errorMessage = 'Failed to create project';
    let statusCode = 500;

    const stdout = error.stdout?.toString() || '';
    const stderr = error.stderr?.toString() || '';

    if (error.message.includes('already exists')) {
      errorMessage = 'A project with this title already exists. Please choose a different project title or delete the existing project first.';
      statusCode = 409; // Conflict
    } else if (stdout.includes('Project workspace already exists')) {
      errorMessage = 'A project with this title already exists. Please choose a different project title or delete the existing project first.';
      statusCode = 409; // Conflict
    } else if (stderr.includes('not a valid repository name') || stderr.includes('fatal: remote error') || stderr.includes('Repository not found')) {
      errorMessage = 'Repository not found. Please check that the repository URL is correct and you have access to it.';
      statusCode = 400; // Bad Request
    } else if (error.message.includes('git clone') || stderr.includes('Cloning into') || stderr.includes('fatal: repository')) {
      errorMessage = 'Failed to clone repository. Please check the repository URL and branch name.';
      statusCode = 400;
    } else if (error.message.includes('Permission denied')) {
      errorMessage = 'Permission denied. Please check file permissions or repository access.';
      statusCode = 403;
    } else if (error.message.includes('timeout')) {
      errorMessage = 'Operation timed out. The repository might be too large or network is slow.';
      statusCode = 408;
    } else if (stdout) {
      // Use stdout message if available (script error messages)
      errorMessage = stdout.trim();
    } else if (stderr) {
      errorMessage = stderr.trim();
    }

    return res.status(statusCode).json({
      success: false,
      message: errorMessage,
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Get project status/info
router.get('/projects', async (req, res) => {
  // Set cache control headers to prevent caching
  res.set({
    'Cache-Control': 'no-cache, no-store, must-revalidate',
    'Pragma': 'no-cache',
    'Expires': '0'
  });

  try {
    const { search, limit = 50, offset = 0 } = req.query;

    let projects;

    if (search) {
      // Search projects
      projects = await Project.search(search, { limit: parseInt(limit) });
    } else {
      // Get all active projects
      projects = await Project.findAll({
        limit: parseInt(limit),
        offset: parseInt(offset)
      });
    }

    // Sync filesystem status for all projects
    for (const project of projects) {
      await project.syncFilesystemStatus();
    }

    res.json({
      success: true,
      projects: projects.map(p => p.toJSON()),
      total: projects.length
    });

  } catch (error) {
    console.error('Error listing projects:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to list projects',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Delete project
router.delete('/projects/:projectSlug', async (req, res) => {
  try {
    const { projectSlug } = req.params;

    if (!projectSlug) {
      return res.status(400).json({
        success: false,
        message: 'Project slug is required'
      });
    }

    // Find project in database
    const project = await Project.findBySlug(projectSlug);
    if (!project) {
      return res.status(404).json({
        success: false,
        message: 'Project not found'
      });
    }

    const docupilotPath = path.join(__dirname, '../../docupilot');
    const docPath = path.join(docupilotPath, projectSlug);

    // Delete documentation directory (repository is already cleaned up after gitingest)
    if (fs.existsSync(docPath)) {
      fs.rmSync(docPath, { recursive: true, force: true });
    }

    // Remove from Docusaurus config
    try {
      await removeFromDocusaurusConfig(projectSlug);
      console.log(`[${new Date().toISOString()}] Removed ${projectSlug} from Docusaurus config`);
    } catch (configError) {
      console.warn('Failed to remove from Docusaurus config:', configError.message);
      // Don't fail the deletion if config update fails
    }

    // Permanently delete from database (since files are already gone)
    await project.delete(true);

    res.json({
      success: true,
      message: 'Project deleted successfully',
      data: project.toJSON()
    });

  } catch (error) {
    console.error('Error deleting project:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete project',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Get single project by slug
router.get('/projects/:projectSlug', async (req, res) => {
  try {
    const { projectSlug } = req.params;

    const project = await Project.findBySlug(projectSlug);
    if (!project) {
      return res.status(404).json({
        success: false,
        message: 'Project not found'
      });
    }

    // Sync filesystem status
    await project.syncFilesystemStatus();

    res.json({
      success: true,
      data: project.toJSON()
    });

  } catch (error) {
    console.error('Error fetching project:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch project',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// Get project statistics
router.get('/statistics', async (req, res) => {
  try {
    const stats = await Project.getStatistics();

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('Error fetching statistics:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch statistics',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

module.exports = router;